:description: This section describes the neo4j-arc, including its architecture and components

[[neo4j-arc]]
= Neo4J Arc

== Installing Library

Neo4j Arc has a https://blog.bitsrc.io/understanding-peer-dependencies-in-javascript-dbdb4ab5a7be[peer dependency] of
neo4j-driver-core 5.9.2, so we will also install it along the way:

[source,bash]
----
yarn add neo4j-devtools-arc neo4j-driver-core@5.9.2
----

== Basic Usage

[source,typescript]
----
import { BasicNode, BasicRelationship, GraphVisualizer } from "neo4j-devtools-arc";

export default function MyGraphComponent(): JSX.Element {

  const nodes: BasicNode[] = [
    {
      id: "1",
      labels: ["Person"],
      properties: {
        name: "Jack",
        age: "20"
      },
      propertyTypes: {
        name: "string",
        age: "number"
      }
    },
    {
      id: "2",
      labels: ["React"],
      properties: {
        name: "ReactJS"
      },
      propertyTypes: {
        name: "string",
      }
    }
  ]

  const links: BasicRelationship[] = [
    {
      id: "3",
      startNodeId: "1",
      endNodeId: "2",
      type: "likes",
      properties: {},
      propertyTypes: {}
    }
  ]

  const isFullscreen = true;

  return (
    <GraphVisualizer
      maxNeighbours={100}
      hasTruncatedFields={false}
      nodes={nodes}
      autocompleteRelationships={false}
      relationships={links}
      isFullscreen={isFullscreen}
      nodeLimitHit={false}
      getAutoCompleteCallback={undefined}
      wheelZoomRequiresModKey={!isFullscreen}
      wheelZoomInfoMessageEnabled={false}
      useGeneratedDefaultColors={false}
      initialZoomToFit={true}
    />
  );
}
----

image:basic-example.png[width=900]

=== Options

==== Turnning Off Inspection Panel

[source,typescript]
----
export default function MyGraphComponent(): JSX.Element {

  return (
    <GraphVisualizer
      ...
      showNodeInspectorPanel={false}
    />
  );
}
----

= Neo4J Browser Internals

The Neo4J Browser is logically composed of 2 parts:

. The neo4j-arc, which is the current part we are discussing
.. The neo4j-arc is based on D3 and implements its own layout, coloring, and link drawing. For example, the calculation
   of arrow, i.e. links, between nodes uses some
   https://github.com/QubitPi/neo4j-browser/blob/master/src/neo4j-arc/graph-visualization/utils/ArcArrow.ts[very complicated math]
   along with very prelimiary MDN standard basic shap specification.
. A user-interface that combines the graph rendering (supported by the graphing module), database, and user
   interaction together

[IMPORTANT]
====
Although we see `<id>` property for every node or relationship in the node inspection panel of Neo4J Browser, those
ID's are NOT generated by neo4j-arc, but https://stackoverflow.com/a/67702695[instead by Neo4J database]. This pattern
should be honored by all client using neo4j-arc library. All nodes or relationships, at the moment of being fed into
the module for graph viauzliation, MUST all have defined ID's.

*neo4j-arc does NOT generate or manage node/rel ID's*

Note: the displayed `<id>` is the value of NodeMode.id
====

[WARNING]
====
We will not have any TypeDoc documentation, because the TypeScript version used in Neo4J Browser is not supprted by the
TypeDoc
====

== Component Diagram (WIP)

image:neo4j-browser.png[width=900]

* The orange triangle labled with "On Canvas Interaction" is discussed in detail in
  link:neo4j-arc/graph-interactions[graph interactions] section
* Sentry.io is initialized in the top index.tsx
* AppInit.tsx is responsible for several initializations:
+
--
** Redux
** Suber (discussed below)
** Apollo GraphQL Client
** Drag & Drop Plugin
--
+
The initialization assumes provider pattern around regular App component:
[source,typescript]
----
<Provider store={store as any}>
  <BusProvider bus={bus}>
    <ApolloProvider client={client}>
      <DndProvider backend={HTML5Backend}>
        <App />
      </DndProvider>
    </ApolloProvider>
  </BusProvider>
</Provider>
----

* Neo4J Browser styling is implemented via https://styled-components.com/[styled-components] and is initialized in App.tsx

=== What is Suber?

Looking at suber-related code (`bus`), we feel that it is very similar to Redux. It's true that both Suber and Redux are
designed to *decouple React components*.

Redux decouples components via "state", which makes it great for shared application state handling. Essentially, if one
component A depends on component B via a state S; when S is updated in B, A gets re-rendered accordingly. Redux is our
choice in this case

But what if component A depends on B via a prop that is not a state? For example, if component B is a database client
and component A is a user registration form, then there is no concept of state S between A and B, because between A and
B is just a one-time username/password message. Application state that is not shared should not go into Redux, it should
go directly into the component that needs it.

This is where https://github.com/oskarhane/suber[suber] comes in.

image:redux-vs-suber.png[width=900]
